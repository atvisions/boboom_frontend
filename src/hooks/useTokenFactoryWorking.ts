import { useState, useEffect, useCallback } from 'react';
import { useAccount, usePublicClient } from 'wagmi';
import { formatEther, parseEther, formatUnits, parseUnits } from 'viem';
import { useContractAddresses } from './useContractConfigSimple';
import { NETWORK_CONFIG } from '../contracts/config-simple';
import OKBTokenArtifact from '../contracts/abis/OKBToken.json';
import TokenFactoryV1Artifact from '../contracts/abis/TokenFactoryV1.json';
import BondingCurveV1Artifact from '../contracts/abis/BondingCurveV1.json';
const OKBTokenABI = (OKBTokenArtifact as any).abi;
const TokenFactoryV1ABI = (TokenFactoryV1Artifact as any).abi;
const BondingCurveV1ABI = (BondingCurveV1Artifact as any).abi;

export function useTokenFactoryWorking() {
  const { addresses, isLoading: isConfigLoading, error: configError } = useContractAddresses();
  const { address } = useAccount();
  const publicClient = usePublicClient();
  const chainIdNum = Number(NETWORK_CONFIG.NETWORK_ID || '11155111');
  
  const [balanceData, setBalanceData] = useState({
    okbBalance: 0,
    okbAllowance: 0,
    okbAllowanceBondingCurve: 0,
  });

  const [okbDecimals, setOkbDecimals] = useState<number>(18); // ÈªòËÆ§18‰ΩçÔºåÂä®ÊÄÅËé∑Âèñ

  const [transactionStates, setTransactionStates] = useState({
    approval: {
      hash: undefined as string | undefined,
      isPending: false,
      isConfirming: false,
      isSuccess: false,
      isFailed: false,
      error: null as any,
    },
    create: {
      hash: undefined as string | undefined,
      isPending: false,
      isConfirming: false,
      isSuccess: false,
      isFailed: false,
      error: null as any,
    },
    trade: {
      hash: undefined as string | undefined,
      isPending: false,
      isConfirming: false,
      isSuccess: false,
      isFailed: false,
      error: null as any,
      type: null as 'buy' | 'sell' | null,
    },
  });

  // Ëé∑Âèñ‰ΩôÈ¢ùÊï∞ÊçÆ
  useEffect(() => {
    const fetchBalances = async () => {
      if (!publicClient || !address || !addresses?.OKB_TOKEN) {
        console.log('Missing requirements for balance fetch:', {
          publicClient: !!publicClient,
          address: !!address,
          okbToken: !!addresses?.OKB_TOKEN
        });
        return;
      }

      try {
        console.log('Fetching balance data for:', address, 'from:', addresses.OKB_TOKEN);

        // È¶ñÂÖàËé∑Âèñ OKB ‰ª£Â∏ÅÁöÑÂ∞èÊï∞‰ΩçÊï∞
        const decimals = await (publicClient as any).readContract({
          address: addresses.OKB_TOKEN,
          abi: OKBTokenABI,
          functionName: 'decimals',
          args: [],
        });

        console.log('OKB decimals:', decimals);
        setOkbDecimals(Number(decimals));

        // Ëé∑Âèñ OKB ‰ΩôÈ¢ù
        const balance = await (publicClient as any).readContract({
          address: addresses.OKB_TOKEN,
          abi: OKBTokenABI,
          functionName: 'balanceOf',
          args: [address],
        });

        console.log('Raw balance:', balance);
        
        // Ëé∑ÂèñÊéàÊùÉÈ¢ùÂ∫¶ÔºàÁªôFactoryÔºâ
        let allowance = 0n;
        if (addresses.TOKEN_FACTORY_V3) {
          try {
            allowance = await (publicClient as any).readContract({
              address: addresses.OKB_TOKEN,
              abi: OKBTokenABI,
              functionName: 'allowance',
              args: [address, addresses.TOKEN_FACTORY_V3],
            }) as bigint;
          } catch (err) {
            console.warn('Failed to get factory allowance:', err);
          }
        }
        
        // Ëé∑ÂèñÊéàÊùÉÈ¢ùÂ∫¶ÔºàÁªôBondingCurveÔºâ
        let allowanceBondingCurve = 0n;
        if (addresses.BONDING_CURVE_V3) {
          try {
            allowanceBondingCurve = await (publicClient as any).readContract({
              address: addresses.OKB_TOKEN,
              abi: OKBTokenABI,
              functionName: 'allowance',
              args: [address, addresses.BONDING_CURVE_V3],
            }) as bigint;
          } catch (err) {
            console.warn('Failed to get bonding curve allowance:', err);
          }
        }
        
        const balanceFormatted = Number(formatUnits(balance as bigint, decimals));
        const allowanceFormatted = Number(formatUnits(allowance, decimals));
        const allowanceBondingCurveFormatted = Number(formatUnits(allowanceBondingCurve, decimals));
        
        console.log('Formatted balances:', {
          balance: balanceFormatted,
          allowance: allowanceFormatted,
          allowanceBondingCurve: allowanceBondingCurveFormatted
        });
        
        console.log('‚úÖ Setting balance data:', {
          okbBalance: balanceFormatted,
          okbAllowance: allowanceFormatted,
          okbAllowanceBondingCurve: allowanceBondingCurveFormatted,
        });

        setBalanceData({
          okbBalance: balanceFormatted,
          okbAllowance: allowanceFormatted,
          okbAllowanceBondingCurve: allowanceBondingCurveFormatted,
        });
      } catch (error) {
        console.error('‚ùå Error fetching balance data:', error);
        console.error('Error details:', {
          address,
          okbTokenAddress: addresses.OKB_TOKEN,
          publicClient: !!publicClient,
          error: error.message
        });
        // ‰øùÊåÅÈªòËÆ§ÂÄºÔºå‰ΩÜ‰∏çÈáçÁΩÆ‰∏∫0Ôºå‰øùÁïô‰πãÂâçÁöÑÂÄº
      }
    };

    console.log('üîç Balance fetch conditions:', {
      hasAddresses: !!addresses,
      hasOkbToken: !!addresses?.OKB_TOKEN,
      hasAddress: !!address,
      hasPublicClient: !!publicClient,
      okbTokenAddress: addresses?.OKB_TOKEN
    });

    if (addresses && address && publicClient) {
      console.log('‚úÖ All conditions met, fetching balances...');
      fetchBalances();
    } else {
      console.log('‚ùå Missing conditions for balance fetch');
    }
  }, [addresses?.OKB_TOKEN, addresses?.TOKEN_FACTORY_V3, addresses?.BONDING_CURVE_V3, address, publicClient]);

  // ÊéàÊùÉ OKB Áªô TokenFactoryÔºàÁî®‰∫éÂàõÂª∫‰ª£Â∏ÅÔºâ
  const approveOKB = useCallback(async (amount: number = 1000000) => {
    if (!addresses?.OKB_TOKEN || !addresses?.TOKEN_FACTORY_V3 || !address) {
      throw new Error('Contract addresses or wallet not ready');
    }

    if (!window.ethereum) {
      throw new Error('MetaMask not found');
    }

    setTransactionStates(prev => ({
      ...prev,
      approval: { ...prev.approval, isPending: true, error: null }
    }));

    try {
      console.log('Starting OKB approval process...');
      console.log('Amount to approve:', amount);
      console.log('Addresses:', {
        OKB_TOKEN: addresses.OKB_TOKEN,
        TOKEN_FACTORY_V3: addresses.TOKEN_FACTORY_V3
      });

      // Ê£ÄÊü• MetaMask
      if (!window.ethereum) {
        throw new Error('MetaMask not found');
      }

      const ethereum = window.ethereum as any;

      // Ê£ÄÊü•ÂΩìÂâçÁΩëÁªú
      const chainId = await ethereum.request({ method: 'eth_chainId' });
      console.log('Current chain ID:', chainId);

      // Ê£ÄÊü•ÂΩìÂâçË¥¶Êà∑
      const accounts = await ethereum.request({ method: 'eth_accounts' });
      console.log('Current accounts:', accounts);

      // Ê£ÄÊü•ÊòØÂê¶ËøûÊé•Âà∞Ê≠£Á°ÆÁöÑÁΩëÁªú (Sepolia = 0xaa36a7)
      if (chainId !== '0xaa36a7') {
        console.warn('Not connected to Sepolia network. Current:', chainId, 'Expected: 0xaa36a7');
      }

      // ÊûÑÂª∫‰∫§ÊòìÊï∞ÊçÆ
      const { encodeFunctionData } = await import('viem');

      const data = encodeFunctionData({
        abi: OKBTokenABI,
        functionName: 'approve',
        args: [addresses.TOKEN_FACTORY_V3, parseUnits(amount.toString(), okbDecimals)],
      });

      console.log('Encoded function data:', data);

      const approveData = {
        to: addresses.OKB_TOKEN,
        from: address,
        data: data,
      };

      console.log('Transaction data:', approveData);
      console.log('Requesting MetaMask signature...');

      const hash = await ethereum.request({
        method: 'eth_sendTransaction',
        params: [approveData],
      });

      console.log('Transaction hash received:', hash);

      setTransactionStates(prev => ({
        ...prev,
        approval: { 
          ...prev.approval, 
          hash, 
          isPending: false, 
          isConfirming: true 
        }
      }));

      // Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
      const receipt = await publicClient?.waitForTransactionReceipt({ hash });
      
      setTransactionStates(prev => ({
        ...prev,
        approval: { 
          ...prev.approval, 
          isConfirming: false, 
          isSuccess: true 
        }
      }));

      // Âà∑Êñ∞‰ΩôÈ¢ù
      setTimeout(() => {
        if (addresses && address && publicClient) {
          // ÈáçÊñ∞Ëé∑Âèñ‰ΩôÈ¢ùÁöÑÈÄªËæë
        }
      }, 1000);

      return hash;
    } catch (error) {
      setTransactionStates(prev => ({
        ...prev,
        approval: { 
          ...prev.approval, 
          isPending: false, 
          isConfirming: false, 
          isFailed: true, 
          error 
        }
      }));
      throw error;
    }
  }, [addresses?.OKB_TOKEN, addresses?.TOKEN_FACTORY_V3, address, publicClient]);

  // ÊéàÊùÉ OKB Áªô BondingCurveÔºàÁî®‰∫é‰π∞Âçñ‰∫§ÊòìÔºâ
  const approveOKBForTrading = useCallback(async (amount: number = 1000000) => {
    if (!addresses?.OKB_TOKEN || !addresses?.BONDING_CURVE_V3 || !address) {
      throw new Error('Contract addresses or wallet not ready');
    }

    if (!window.ethereum) {
      throw new Error('MetaMask not found');
    }

    setTransactionStates(prev => ({
      ...prev,
      approval: { ...prev.approval, isPending: true, error: null }
    }));

    try {
      console.log('Starting OKB approval for trading...');
      console.log('Amount to approve:', amount);
      console.log('Addresses:', {
        OKB_TOKEN: addresses.OKB_TOKEN,
        BONDING_CURVE_V3: addresses.BONDING_CURVE_V3
      });

      const ethereum = window.ethereum as any;

      // ÊûÑÂª∫‰∫§ÊòìÊï∞ÊçÆ
      const { encodeFunctionData } = await import('viem');

      const data = encodeFunctionData({
        abi: OKBTokenABI,
        functionName: 'approve',
        args: [addresses.BONDING_CURVE_V3, parseUnits(amount.toString(), okbDecimals)],
      });

      const txData = {
        to: addresses.OKB_TOKEN,
        from: address,
        data: data,
      };

      console.log('Requesting MetaMask signature for OKB approval...');
      const hash = await ethereum.request({
        method: 'eth_sendTransaction',
        params: [txData],
      });

      console.log('Approval transaction hash received:', hash);

      setTransactionStates(prev => ({
        ...prev,
        approval: {
          ...prev.approval,
          isPending: false,
          isConfirming: true
        }
      }));

      // Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
      const receipt = await publicClient?.waitForTransactionReceipt({ hash });

      setTransactionStates(prev => ({
        ...prev,
        approval: {
          ...prev.approval,
          isConfirming: false,
          isSuccess: true
        }
      }));

      // Âà∑Êñ∞‰ΩôÈ¢ù
      setTimeout(() => {
        if (addresses && address && publicClient) {
          // ÈáçÊñ∞Ëé∑Âèñ‰ΩôÈ¢ùÁöÑÈÄªËæë
        }
      }, 1000);

      return hash;
    } catch (error) {
      setTransactionStates(prev => ({
        ...prev,
        approval: {
          ...prev.approval,
          isPending: false,
          isConfirming: false,
          isFailed: true,
          error
        }
      }));
      throw error;
    }
  }, [addresses?.OKB_TOKEN, addresses?.BONDING_CURVE_V3, address, publicClient]);

  // ÂàõÂª∫‰ª£Â∏ÅÊñπÊ≥ï
  const createToken = useCallback(async (tokenData: any) => {
    if (!addresses?.TOKEN_FACTORY_V3 || !address) {
      throw new Error('Contract addresses or wallet not ready');
    }

    if (!window.ethereum) {
      throw new Error('MetaMask not found');
    }

    setTransactionStates(prev => ({
      ...prev,
      create: { ...prev.create, isPending: true, error: null }
    }));

    try {
      const ethereum = window.ethereum as any;
      
      // ÊûÑÂª∫‰∫§ÊòìÊï∞ÊçÆ
      const { encodeFunctionData } = await import('viem');

      const createData = {
        to: addresses.TOKEN_FACTORY_V3,
        from: address,
        data: encodeFunctionData({
          abi: TokenFactoryV1ABI,
          functionName: 'createToken',
          args: [
            tokenData.name,
            tokenData.symbol,
            tokenData.description,
            tokenData.imageUrl,
            tokenData.website || '',
            tokenData.twitter || '',
            tokenData.telegram || '',
          ],
        }),
      };

      const hash = await ethereum.request({
        method: 'eth_sendTransaction',
        params: [createData],
      });

      setTransactionStates(prev => ({
        ...prev,
        create: { 
          ...prev.create, 
          hash, 
          isPending: false, 
          isConfirming: true 
        }
      }));

      // Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
      const receipt = await publicClient?.waitForTransactionReceipt({ hash });
      
      setTransactionStates(prev => ({
        ...prev,
        create: { 
          ...prev.create, 
          isConfirming: false, 
          isSuccess: true 
        }
      }));

      return hash;
    } catch (error) {
      setTransactionStates(prev => ({
        ...prev,
        create: { 
          ...prev.create, 
          isPending: false, 
          isConfirming: false, 
          isFailed: true, 
          error 
        }
      }));
      throw error;
    }
  }, [addresses?.TOKEN_FACTORY_V3, address, publicClient]);

  // Â¶ÇÊûúÈÖçÁΩÆËøòÂú®Âä†ËΩΩ‰∏≠ÔºåËøîÂõûÂä†ËΩΩÁä∂ÊÄÅ
  if (isConfigLoading || !addresses) {
    return {
      isConfigLoading: true,
      configError,
      // Áä∂ÊÄÅ
      isApprovalPending: false,
      isApprovalConfirming: false,
      isApprovalSuccess: false,
      isApprovalFailed: false,
      isCreatePending: false,
      isCreateConfirming: false,
      isCreateSuccess: false,
      isCreateFailed: false,
      okbBalance: 0,
      okbAllowance: 0,
      okbAllowanceBondingCurve: 0,
      // ÊñπÊ≥ï
      approveOKB: () => Promise.reject('Configuration not loaded'),
      approveOKBForTrading: () => Promise.reject('Configuration not loaded'),
      createToken: () => Promise.reject('Configuration not loaded'),
      createTokenWithPurchase: () => Promise.reject('Configuration not loaded'),
      buyToken: () => {},
      sellToken: () => {},
      checkOkbAllowance: () => 0,
      getBuyQuote: () => Promise.resolve(null),
      getSellQuote: () => Promise.resolve(null),
      getCurrentPrice: () => Promise.resolve(0),
      getTokenBalance: () => Promise.resolve(0),
      getOkbBalance: () => 0,
      refetchOkbBalance: () => {},
      refetchOkbAllowance: () => {},
      refetchOkbAllowanceBondingCurve: () => {},
      approvalError: null,
      createError: null,
      approvalReceiptError: null,
      createReceiptError: null,
      approvalHash: undefined,
      createHash: undefined,
      actualCreateHash: undefined,
    };
  }

  return {
    isConfigLoading: false,
    configError: null,
    // ÊéàÊùÉÁä∂ÊÄÅ
    approvalHash: transactionStates.approval.hash,
    isApprovalPending: transactionStates.approval.isPending,
    isApprovalConfirming: transactionStates.approval.isConfirming,
    isApprovalSuccess: transactionStates.approval.isSuccess,
    isApprovalFailed: transactionStates.approval.isFailed,
    approvalError: transactionStates.approval.error,
    approvalReceiptError: null,
    // ÂàõÂª∫Áä∂ÊÄÅ
    createHash: transactionStates.create.hash,
    actualCreateHash: transactionStates.create.hash,
    isCreatePending: transactionStates.create.isPending,
    isCreateConfirming: transactionStates.create.isConfirming,
    isCreateSuccess: transactionStates.create.isSuccess,
    isCreateFailed: transactionStates.create.isFailed,
    createError: transactionStates.create.error,
    createReceiptError: null,
    // ‰∫§ÊòìÁä∂ÊÄÅ
    tradeHash: transactionStates.trade.hash,
    isTradePending: transactionStates.trade.isPending,
    isTradeConfirming: transactionStates.trade.isConfirming,
    isTradeSuccess: transactionStates.trade.isSuccess,
    isTradeFailed: transactionStates.trade.isFailed,
    tradeError: transactionStates.trade.error,
    tradeType: transactionStates.trade.type,
    // ÈáçÁΩÆÂáΩÊï∞
    resetTradeState: () => {
      setTransactionStates(prev => ({
        ...prev,
        trade: {
          hash: undefined,
          isPending: false,
          isConfirming: false,
          isSuccess: false,
          isFailed: false,
          error: null,
          type: null,
        }
      }));
    },
    // Êï∞ÊçÆ
    okbBalance: balanceData.okbBalance,
    okbAllowance: balanceData.okbAllowance,
    okbAllowanceBondingCurve: balanceData.okbAllowanceBondingCurve,
    refetchOkbBalance: () => {
      // ÈáçÊñ∞Ëé∑Âèñ‰ΩôÈ¢ùÊï∞ÊçÆÁöÑÈÄªËæëÂèØ‰ª•Âú®ËøôÈáåÂÆûÁé∞
    },
    refetchOkbAllowance: () => {},
    refetchOkbAllowanceBondingCurve: () => {},
    // ÊñπÊ≥ï
    createToken,
    createTokenWithPurchase: async (tokenData: any) => {
      const okbAmount = tokenData.initialPurchase;
      if (!addresses?.TOKEN_FACTORY_V3 || !address) {
        throw new Error('Contract addresses or wallet not ready');
      }

      if (!window.ethereum) {
        throw new Error('MetaMask not found');
      }

      console.log('Creating token with purchase...');
      console.log('Token data:', tokenData);
      console.log('OKB amount:', okbAmount);

      setTransactionStates(prev => ({
        ...prev,
        create: { ...prev.create, isPending: true, error: null }
      }));

      try {
        const ethereum = window.ethereum as any;

        // ÊûÑÂª∫Â∏¶Ë¥≠‰π∞ÁöÑÂàõÂª∫‰∫§ÊòìÊï∞ÊçÆ
        const { encodeFunctionData } = await import('viem');

        const data = encodeFunctionData({
          abi: TokenFactoryV1ABI,
          functionName: 'createTokenWithPurchase',
          args: [
            tokenData.name,
            tokenData.symbol,
            tokenData.description,
            tokenData.imageUrl,
            tokenData.website || '',
            tokenData.twitter || '',
            tokenData.telegram || '',
            parseUnits(okbAmount.toString(), okbDecimals), // ÂàùÂßãË¥≠‰π∞ÈáëÈ¢ù
          ],
        });

        console.log('Create with purchase transaction data:', data);

        const createData = {
          to: addresses.TOKEN_FACTORY_V3,
          from: address,
          data: data,
        };

        console.log('Requesting MetaMask signature for create with purchase...');

        const hash = await ethereum.request({
          method: 'eth_sendTransaction',
          params: [createData],
        });

        console.log('Create with purchase transaction hash received:', hash);

        setTransactionStates(prev => ({
          ...prev,
          create: {
            ...prev.create,
            hash,
            isPending: false,
            isConfirming: true
          }
        }));

        // Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
        const receipt = await publicClient?.waitForTransactionReceipt({ hash });

        setTransactionStates(prev => ({
          ...prev,
          create: {
            ...prev.create,
            isConfirming: false,
            isSuccess: true
          }
        }));

        return hash;
      } catch (error) {
        console.error('Error creating token with purchase:', error);
        setTransactionStates(prev => ({
          ...prev,
          create: {
            ...prev.create,
            isPending: false,
            isConfirming: false,
            isFailed: true,
            error: error as Error
          }
        }));
        throw error;
      }
    },
    approveOKB,
    approveOKBForTrading,
    checkOkbAllowance: () => balanceData.okbAllowance,
    buyToken: async (tokenAddress: string, okbAmount: number) => {
      if (!addresses?.BONDING_CURVE_V3 || !address) {
        throw new Error('Contract addresses or wallet not ready');
      }

      if (!window.ethereum) {
        throw new Error('MetaMask not found');
      }

      console.log('Starting buy token process...');
      console.log('Token address:', tokenAddress);
      console.log('OKB amount:', okbAmount);

      try {
        // ËÆæÁΩÆ‰∫§ÊòìÂºÄÂßãÁä∂ÊÄÅ
        setTransactionStates(prev => ({
          ...prev,
          trade: {
            ...prev.trade,
            isPending: true,
            isConfirming: false,
            isSuccess: false,
            isFailed: false,
            type: 'buy',
            error: null
          }
        }));

        const ethereum = window.ethereum as any;

        // ÊûÑÂª∫Ë¥≠‰π∞‰∫§ÊòìÊï∞ÊçÆ
        const { encodeFunctionData } = await import('viem');

        const data = encodeFunctionData({
          abi: BondingCurveV1ABI,
          functionName: 'buyTokens',
          args: [tokenAddress, parseUnits(okbAmount.toString(), okbDecimals), parseEther('0')], // token, okbIn, minTokensOut
        });

        console.log('Buy transaction data:', data);

        const buyData = {
          to: addresses.BONDING_CURVE_V3,
          from: address,
          data: data,
        };

        console.log('Requesting MetaMask signature for buy...');

        const hash = await ethereum.request({
          method: 'eth_sendTransaction',
          params: [buyData],
        });

        console.log('Buy transaction hash received:', hash);

        // ËÆæÁΩÆ‰∫§ÊòìÁ°ÆËÆ§‰∏≠Áä∂ÊÄÅ
        setTransactionStates(prev => ({
          ...prev,
          trade: {
            ...prev.trade,
            hash,
            isPending: false,
            isConfirming: true
          }
        }));

        // Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
        const receipt = await publicClient?.waitForTransactionReceipt({ hash });
        console.log('Buy transaction confirmed:', receipt);

        // Ê£ÄÊü•‰∫§ÊòìÁä∂ÊÄÅ
        if (receipt?.status === 'reverted') {
          throw new Error('Transaction failed: execution reverted');
        }

        // ËÆæÁΩÆ‰∫§ÊòìÊàêÂäüÁä∂ÊÄÅ
        setTransactionStates(prev => ({
          ...prev,
          trade: {
            ...prev.trade,
            isConfirming: false,
            isSuccess: true
          }
        }));

        return hash;
      } catch (error) {
        console.error('Error buying tokens:', error);

        // ËÆæÁΩÆ‰∫§ÊòìÂ§±Ë¥•Áä∂ÊÄÅ
        setTransactionStates(prev => ({
          ...prev,
          trade: {
            ...prev.trade,
            isPending: false,
            isConfirming: false,
            isFailed: true,
            error
          }
        }));

        throw error;
      }
    },
    sellToken: async (tokenAddress: string, tokenAmount: number) => {
      if (!addresses?.BONDING_CURVE_V3 || !address) {
        console.log('Missing requirements for sell:', {
          bondingCurve: !!addresses?.BONDING_CURVE_V3,
          userAddress: !!address
        });
        throw new Error('Missing contract addresses or user address');
      }

      try {
        // ËÆæÁΩÆ‰∫§ÊòìÂºÄÂßãÁä∂ÊÄÅ
        setTransactionStates(prev => ({
          ...prev,
          trade: {
            ...prev.trade,
            isPending: true,
            isConfirming: false,
            isSuccess: false,
            isFailed: false,
            type: 'sell',
            error: null
          }
        }));

        const ethereum = window.ethereum as any;

        console.log('Starting sell process...');
        console.log('Token amount to sell:', tokenAmount);
        console.log('Addresses:', { bondingCurve: addresses.BONDING_CURVE_V3, token: tokenAddress });

        // ÊûÑÂª∫ÂçñÂá∫‰∫§ÊòìÊï∞ÊçÆ
        const { encodeFunctionData } = await import('viem');

        const data = encodeFunctionData({
          abi: BondingCurveV1ABI,
          functionName: 'sellTokens',
          args: [tokenAddress, parseEther(tokenAmount.toString()), parseUnits('0', okbDecimals)], // token, tokensIn, minOkbOut
        });

        console.log('Sell transaction data:', data);

        const sellData = {
          to: addresses.BONDING_CURVE_V3,
          from: address,
          data: data,
        };

        console.log('Requesting MetaMask signature for sell...');

        const hash = await ethereum.request({
          method: 'eth_sendTransaction',
          params: [sellData],
        });

        console.log('Sell transaction hash received:', hash);

        // ËÆæÁΩÆ‰∫§ÊòìÁ°ÆËÆ§‰∏≠Áä∂ÊÄÅ
        setTransactionStates(prev => ({
          ...prev,
          trade: {
            ...prev.trade,
            hash,
            isPending: false,
            isConfirming: true
          }
        }));

        // Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
        const receipt = await publicClient?.waitForTransactionReceipt({ hash });
        console.log('Sell transaction confirmed:', receipt);

        // Ê£ÄÊü•‰∫§ÊòìÁä∂ÊÄÅ
        if (receipt?.status === 'reverted') {
          throw new Error('Transaction failed: execution reverted');
        }

        // ËÆæÁΩÆ‰∫§ÊòìÊàêÂäüÁä∂ÊÄÅ
        setTransactionStates(prev => ({
          ...prev,
          trade: {
            ...prev.trade,
            isConfirming: false,
            isSuccess: true
          }
        }));

        return hash;
      } catch (error) {
        console.error('Error selling tokens:', error);

        // ËÆæÁΩÆ‰∫§ÊòìÂ§±Ë¥•Áä∂ÊÄÅ
        setTransactionStates(prev => ({
          ...prev,
          trade: {
            ...prev.trade,
            isPending: false,
            isConfirming: false,
            isFailed: true,
            error
          }
        }));

        throw error;
      }
    },
    getBuyQuote: async (tokenAddress: string, okbAmount: number) => {
      if (!publicClient || !addresses?.BONDING_CURVE_V3) {
        console.log('Missing requirements for buy quote:', {
          publicClient: !!publicClient,
          bondingCurve: !!addresses?.BONDING_CURVE_V3
        });
        return null;
      }

      try {
        console.log('Getting buy quote for:', { tokenAddress, okbAmount });

        const quote = await (publicClient as any).readContract({
          address: addresses.BONDING_CURVE_V3,
          abi: BondingCurveV1ABI,
          functionName: 'getQuoteBuy',
          args: [tokenAddress, parseUnits(okbAmount.toString(), okbDecimals)],
        });

        console.log('Raw buy quote:', quote);

        if (quote && Array.isArray(quote) && quote.length >= 3) {
          const tokensOut = Number(formatEther(quote[0] as bigint));
          const priceAfter = Number(formatUnits(quote[1] as bigint, okbDecimals));
          const fee = Number(formatUnits(quote[2] as bigint, okbDecimals));

          const result = {
            tokenAmount: tokensOut,
            tokensOut: tokensOut, // TradingPanel ÊúüÊúõÁöÑÂ±ûÊÄßÂêç
            fee,
            priceAfter,
            totalCost: okbAmount,
            priceImpact: 0, // ÂèØ‰ª•Ê†πÊçÆÈúÄË¶ÅËÆ°ÁÆó‰ª∑Ê†ºÂΩ±Âìç
          };

          console.log('Formatted buy quote:', result);
          return result;
        }

        return null;
      } catch (error) {
        console.error('Error getting buy quote:', error);
        return null;
      }
    },

    getSellQuote: async (tokenAddress: string, tokenAmount: number) => {
      if (!publicClient || !addresses?.BONDING_CURVE_V3) {
        console.log('Missing requirements for sell quote:', {
          publicClient: !!publicClient,
          bondingCurve: !!addresses?.BONDING_CURVE_V3
        });
        return null;
      }

      try {
        console.log('Getting sell quote for:', { tokenAddress, tokenAmount });

        const quote = await (publicClient as any).readContract({
          address: addresses.BONDING_CURVE_V3,
          abi: BondingCurveV1ABI,
          functionName: 'getQuoteSell',
          args: [tokenAddress, parseEther(tokenAmount.toString())],
        });

        console.log('Raw sell quote:', quote);

        if (quote && Array.isArray(quote) && quote.length >= 3) {
          const okbOut = Number(formatUnits(quote[0] as bigint, okbDecimals));
          const priceAfter = Number(formatUnits(quote[1] as bigint, okbDecimals));
          const fee = Number(formatUnits(quote[2] as bigint, okbDecimals));

          const result = {
            okbAmount: okbOut,
            okbOut: okbOut, // TradingPanel ÊúüÊúõÁöÑÂ±ûÊÄßÂêç
            fee,
            priceAfter,
            totalReceived: okbOut - fee,
            priceImpact: 0, // ÂèØ‰ª•Ê†πÊçÆÈúÄË¶ÅËÆ°ÁÆó‰ª∑Ê†ºÂΩ±Âìç
          };

          console.log('Formatted sell quote:', result);
          return result;
        }

        return null;
      } catch (error) {
        console.error('Error getting sell quote:', error);
        return null;
      }
    },

    getCurrentPrice: async (tokenAddress: string) => {
      if (!publicClient || !addresses?.BONDING_CURVE_V3 || !tokenAddress) {
        return 0;
      }

      try {
        // Ëé∑ÂèñÂΩìÂâç‰ª∑Ê†º - ÂèØ‰ª•ÈÄöËøáËé∑ÂèñÂ∞èÈ¢ù‰π∞ÂÖ•Êä•‰ª∑Êù•‰º∞ÁÆó
        // Ê≥®ÊÑèÔºöËôΩÁÑ∂ÂèòÈáèÂêçÊòØBONDING_CURVE_V3Ôºå‰ΩÜÂÆûÈôÖÊåáÂêëÁöÑÊòØV1ÂêàÁ∫¶Âú∞ÂùÄ
        const quote = await (publicClient as any).readContract({
          address: addresses.BONDING_CURVE_V3,
          abi: BondingCurveV1ABI,
          functionName: 'getQuoteBuy',
          args: [tokenAddress, parseUnits('1', okbDecimals)], // 1 OKB ÁöÑÊä•‰ª∑
        });

        if (quote && Array.isArray(quote) && quote.length >= 1) {
          const tokenAmount = Number(formatEther(quote[0] as bigint));
          return tokenAmount > 0 ? 1 / tokenAmount : 0; // OKB per token
        }

        return 0;
      } catch (error) {
        console.error('Error getting current price:', error);
        return 0;
      }
    },

    getTokenBalance: async (tokenAddress: string) => {
      if (!publicClient || !address || !tokenAddress) {
        console.log('getTokenBalance: Missing required data', { publicClient: !!publicClient, address, tokenAddress });
        return 0;
      }

      try {
        console.log('Getting token balance for:', { tokenAddress, userAddress: address });

        const balance = await (publicClient as any).readContract({
          address: tokenAddress,
          abi: [
            {
              "inputs": [{"name": "account", "type": "address"}],
              "name": "balanceOf",
              "outputs": [{"name": "", "type": "uint256"}],
              "stateMutability": "view",
              "type": "function"
            }
          ],
          functionName: 'balanceOf',
          args: [address],
        });

        console.log('Raw token balance:', balance);
        const formattedBalance = Number(formatEther(balance as bigint));
        console.log('Formatted token balance:', formattedBalance);

        return formattedBalance;
      } catch (error) {
        console.error('Error getting token balance:', error);
        return 0;
      }
    },
    getOkbBalance: () => balanceData.okbBalance,
  };
}
